// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.2
// source: ricedb.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  ClientReadableStream,
  type ClientUnaryCall,
  ClientWritableStream,
  handleClientStreamingCall,
  handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "ricedb";

/** Auth */
export interface LoginRequest {
  username: string;
  password: string;
}

export interface LoginResponse {
  token: string;
  userId: Long;
  role: string;
}

export interface CreateUserRequest {
  username: string;
  password: string;
  /** "admin" or "user" */
  role: string;
}

export interface CreateUserResponse {
  userId: Long;
  message: string;
}

export interface DeleteUserRequest {
  username: string;
}

export interface DeleteUserResponse {
  success: boolean;
  message: string;
}

/** Health check */
export interface HealthRequest {
}

export interface HealthResponse {
  status: string;
  version: string;
}

/** Node */
export interface Node {
  id: Long;
  /**
   * Vector is internal (HDC), typically not returned to client or returned as bytes if needed
   * repeated float vector = 2; // Deprecated
   */
  metadata: Buffer;
}

/** Insert operations */
export interface InsertRequest {
  id: Long;
  /** Raw text input for HDC encoding */
  text: string;
  /** JSON-encoded metadata */
  metadata: Buffer;
  userId: Long;
  sessionId?: string | undefined;
}

export interface InsertResponse {
  success: boolean;
  nodeId: Long;
  message: string;
}

export interface BatchInsertResponse {
  count: number;
  nodeIds: Long[];
}

/** Get/Delete Node */
export interface GetNodeRequest {
  nodeId: Long;
}

export interface GetNodeResponse {
  node: Node | undefined;
}

export interface DeleteNodeRequest {
  nodeId: Long;
  sessionId?: string | undefined;
}

export interface DeleteNodeResponse {
  success: boolean;
  message: string;
}

/** Search operations */
export interface SearchRequest {
  /** Raw text query for HDC encoding */
  queryText: string;
  userId: Long;
  k: number;
  sessionId?:
    | string
    | undefined;
  /** JSON-encoded metadata filter */
  filter: string;
}

export interface SearchResponse {
  results: SearchResult[];
}

export interface SearchResult {
  id: Long;
  similarity: number;
  /** JSON-encoded metadata */
  metadata: Buffer;
}

/** ACL Operations */
export interface Permissions {
  read: boolean;
  write: boolean;
  delete: boolean;
}

export interface GrantPermissionRequest {
  nodeId: Long;
  targetUserId: Long;
  permissions: Permissions | undefined;
}

export interface GrantPermissionResponse {
  success: boolean;
  message: string;
}

export interface RevokePermissionRequest {
  nodeId: Long;
  targetUserId: Long;
}

export interface RevokePermissionResponse {
  success: boolean;
  message: string;
}

/** Graph Operations */
export interface AddEdgeRequest {
  from: Long;
  to: Long;
  relation: string;
  weight: number;
}

export interface AddEdgeResponse {
  success: boolean;
  message: string;
}

export interface GetNeighborsRequest {
  nodeId: Long;
  relation?: string | undefined;
}

export interface GetNeighborsResponse {
  nodeId: Long;
  neighbors: Long[];
}

export interface TraverseGraphRequest {
  start: Long;
  maxDepth: number;
}

export interface TraverseGraphResponse {
  start: Long;
  visited: Long[];
}

/** PubSub */
export interface SubscribeRequest {
  /** "all", "node", "semantic" */
  filterType: string;
  nodeId?:
    | Long
    | undefined;
  /** Deprecated */
  vector: number[];
  threshold?:
    | number
    | undefined;
  /** Text to encode for semantic subscription */
  queryText: string;
}

export interface PubSubEvent {
  /** "inserted", "updated", "deleted" */
  type: string;
  /** For inserted/updated */
  node:
    | Node
    | undefined;
  /** For deleted */
  nodeId: Long;
}

/** SDM operations */
export interface BitVector {
  /** 16 chunks of 64 bits = 1024 bits */
  chunks: Long[];
}

export interface WriteMemoryRequest {
  address: BitVector | undefined;
  data: BitVector | undefined;
  userId: Long;
}

export interface WriteMemoryResponse {
  success: boolean;
  message: string;
}

export interface ReadMemoryRequest {
  address: BitVector | undefined;
  userId: Long;
}

export interface ReadMemoryResponse {
  data: BitVector | undefined;
}

export interface MemoryEntry {
  id: string;
  sessionId: string;
  agentId: string;
  content: string;
  timestamp: Long;
  metadata: { [key: string]: string };
  expiresAt?: Long | undefined;
}

export interface MemoryEntry_MetadataEntry {
  key: string;
  value: string;
}

export interface AddMemoryRequest {
  sessionId: string;
  agentId: string;
  content: string;
  metadata: { [key: string]: string };
  ttlSeconds?: Long | undefined;
}

export interface AddMemoryRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface AddMemoryResponse {
  success: boolean;
  message: string;
  entry: MemoryEntry | undefined;
}

export interface GetMemoryRequest {
  sessionId: string;
  limit: number;
  afterTimestamp: Long;
  filter: { [key: string]: string };
}

export interface GetMemoryRequest_FilterEntry {
  key: string;
  value: string;
}

export interface GetMemoryResponse {
  entries: MemoryEntry[];
}

export interface ClearMemoryRequest {
  sessionId: string;
}

export interface ClearMemoryResponse {
  success: boolean;
  message: string;
}

export interface WatchMemoryRequest {
  sessionId: string;
}

export interface MemoryEvent {
  /** "added" */
  type: string;
  entry: MemoryEntry | undefined;
}

/** Cortex Session Messages */
export interface CreateSessionRequest {
  parentSessionId?: string | undefined;
}

export interface CreateSessionResponse {
  sessionId: string;
}

export interface SnapshotSessionRequest {
  sessionId: string;
  path: string;
}

export interface SnapshotSessionResponse {
  success: boolean;
}

export interface LoadSessionRequest {
  path: string;
}

export interface LoadSessionResponse {
  sessionId: string;
}

export interface CommitSessionRequest {
  sessionId: string;
  /** "overwrite" (default), "bundle", "average" */
  mergeStrategy: string;
}

export interface CommitSessionResponse {
  success: boolean;
}

export interface DropSessionRequest {
  sessionId: string;
}

export interface DropSessionResponse {
  success: boolean;
}

function createBaseLoginRequest(): LoginRequest {
  return { username: "", password: "" };
}

export const LoginRequest = {
  encode(message: LoginRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoginRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginRequest {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: LoginRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginRequest>, I>>(base?: I): LoginRequest {
    return LoginRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginRequest>, I>>(object: I): LoginRequest {
    const message = createBaseLoginRequest();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseLoginResponse(): LoginResponse {
  return { token: "", userId: Long.UZERO, role: "" };
}

export const LoginResponse = {
  encode(message: LoginResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (!message.userId.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.userId);
    }
    if (message.role !== "") {
      writer.uint32(26).string(message.role);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoginResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.userId = reader.uint64() as Long;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.role = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginResponse {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      userId: isSet(object.userId) ? Long.fromValue(object.userId) : Long.UZERO,
      role: isSet(object.role) ? globalThis.String(object.role) : "",
    };
  },

  toJSON(message: LoginResponse): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (!message.userId.equals(Long.UZERO)) {
      obj.userId = (message.userId || Long.UZERO).toString();
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginResponse>, I>>(base?: I): LoginResponse {
    return LoginResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginResponse>, I>>(object: I): LoginResponse {
    const message = createBaseLoginResponse();
    message.token = object.token ?? "";
    message.userId = (object.userId !== undefined && object.userId !== null)
      ? Long.fromValue(object.userId)
      : Long.UZERO;
    message.role = object.role ?? "";
    return message;
  },
};

function createBaseCreateUserRequest(): CreateUserRequest {
  return { username: "", password: "", role: "" };
}

export const CreateUserRequest = {
  encode(message: CreateUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.role !== "") {
      writer.uint32(26).string(message.role);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateUserRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.role = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUserRequest {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
    };
  },

  toJSON(message: CreateUserRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateUserRequest>, I>>(base?: I): CreateUserRequest {
    return CreateUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateUserRequest>, I>>(object: I): CreateUserRequest {
    const message = createBaseCreateUserRequest();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    message.role = object.role ?? "";
    return message;
  },
};

function createBaseCreateUserResponse(): CreateUserResponse {
  return { userId: Long.UZERO, message: "" };
}

export const CreateUserResponse = {
  encode(message: CreateUserResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.userId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateUserResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.userId = reader.uint64() as Long;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUserResponse {
    return {
      userId: isSet(object.userId) ? Long.fromValue(object.userId) : Long.UZERO,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: CreateUserResponse): unknown {
    const obj: any = {};
    if (!message.userId.equals(Long.UZERO)) {
      obj.userId = (message.userId || Long.UZERO).toString();
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateUserResponse>, I>>(base?: I): CreateUserResponse {
    return CreateUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateUserResponse>, I>>(object: I): CreateUserResponse {
    const message = createBaseCreateUserResponse();
    message.userId = (object.userId !== undefined && object.userId !== null)
      ? Long.fromValue(object.userId)
      : Long.UZERO;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseDeleteUserRequest(): DeleteUserRequest {
  return { username: "" };
}

export const DeleteUserRequest = {
  encode(message: DeleteUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteUserRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUserRequest {
    return { username: isSet(object.username) ? globalThis.String(object.username) : "" };
  },

  toJSON(message: DeleteUserRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserRequest>, I>>(base?: I): DeleteUserRequest {
    return DeleteUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteUserRequest>, I>>(object: I): DeleteUserRequest {
    const message = createBaseDeleteUserRequest();
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseDeleteUserResponse(): DeleteUserResponse {
  return { success: false, message: "" };
}

export const DeleteUserResponse = {
  encode(message: DeleteUserResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteUserResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUserResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: DeleteUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserResponse>, I>>(base?: I): DeleteUserResponse {
    return DeleteUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteUserResponse>, I>>(object: I): DeleteUserResponse {
    const message = createBaseDeleteUserResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseHealthRequest(): HealthRequest {
  return {};
}

export const HealthRequest = {
  encode(_: HealthRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HealthRequest {
    return {};
  },

  toJSON(_: HealthRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthRequest>, I>>(base?: I): HealthRequest {
    return HealthRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthRequest>, I>>(_: I): HealthRequest {
    const message = createBaseHealthRequest();
    return message;
  },
};

function createBaseHealthResponse(): HealthResponse {
  return { status: "", version: "" };
}

export const HealthResponse = {
  encode(message: HealthResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthResponse {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: HealthResponse): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthResponse>, I>>(base?: I): HealthResponse {
    return HealthResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthResponse>, I>>(object: I): HealthResponse {
    const message = createBaseHealthResponse();
    message.status = object.status ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseNode(): Node {
  return { id: Long.UZERO, metadata: Buffer.alloc(0) };
}

export const Node = {
  encode(message: Node, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.id.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.metadata.length !== 0) {
      writer.uint32(26).bytes(message.metadata);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Node {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64() as Long;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metadata = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node {
    return {
      id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO,
      metadata: isSet(object.metadata) ? Buffer.from(bytesFromBase64(object.metadata)) : Buffer.alloc(0),
    };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    if (!message.id.equals(Long.UZERO)) {
      obj.id = (message.id || Long.UZERO).toString();
    }
    if (message.metadata.length !== 0) {
      obj.metadata = base64FromBytes(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Node>, I>>(base?: I): Node {
    return Node.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Node>, I>>(object: I): Node {
    const message = createBaseNode();
    message.id = (object.id !== undefined && object.id !== null) ? Long.fromValue(object.id) : Long.UZERO;
    message.metadata = object.metadata ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseInsertRequest(): InsertRequest {
  return { id: Long.UZERO, text: "", metadata: Buffer.alloc(0), userId: Long.UZERO, sessionId: undefined };
}

export const InsertRequest = {
  encode(message: InsertRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.id.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    if (message.metadata.length !== 0) {
      writer.uint32(26).bytes(message.metadata);
    }
    if (!message.userId.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.userId);
    }
    if (message.sessionId !== undefined) {
      writer.uint32(42).string(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InsertRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64() as Long;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metadata = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.userId = reader.uint64() as Long;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sessionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertRequest {
    return {
      id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO,
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      metadata: isSet(object.metadata) ? Buffer.from(bytesFromBase64(object.metadata)) : Buffer.alloc(0),
      userId: isSet(object.userId) ? Long.fromValue(object.userId) : Long.UZERO,
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : undefined,
    };
  },

  toJSON(message: InsertRequest): unknown {
    const obj: any = {};
    if (!message.id.equals(Long.UZERO)) {
      obj.id = (message.id || Long.UZERO).toString();
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.metadata.length !== 0) {
      obj.metadata = base64FromBytes(message.metadata);
    }
    if (!message.userId.equals(Long.UZERO)) {
      obj.userId = (message.userId || Long.UZERO).toString();
    }
    if (message.sessionId !== undefined) {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InsertRequest>, I>>(base?: I): InsertRequest {
    return InsertRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InsertRequest>, I>>(object: I): InsertRequest {
    const message = createBaseInsertRequest();
    message.id = (object.id !== undefined && object.id !== null) ? Long.fromValue(object.id) : Long.UZERO;
    message.text = object.text ?? "";
    message.metadata = object.metadata ?? Buffer.alloc(0);
    message.userId = (object.userId !== undefined && object.userId !== null)
      ? Long.fromValue(object.userId)
      : Long.UZERO;
    message.sessionId = object.sessionId ?? undefined;
    return message;
  },
};

function createBaseInsertResponse(): InsertResponse {
  return { success: false, nodeId: Long.UZERO, message: "" };
}

export const InsertResponse = {
  encode(message: InsertResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (!message.nodeId.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.nodeId);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InsertResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nodeId = reader.uint64() as Long;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      nodeId: isSet(object.nodeId) ? Long.fromValue(object.nodeId) : Long.UZERO,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: InsertResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (!message.nodeId.equals(Long.UZERO)) {
      obj.nodeId = (message.nodeId || Long.UZERO).toString();
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InsertResponse>, I>>(base?: I): InsertResponse {
    return InsertResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InsertResponse>, I>>(object: I): InsertResponse {
    const message = createBaseInsertResponse();
    message.success = object.success ?? false;
    message.nodeId = (object.nodeId !== undefined && object.nodeId !== null)
      ? Long.fromValue(object.nodeId)
      : Long.UZERO;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseBatchInsertResponse(): BatchInsertResponse {
  return { count: 0, nodeIds: [] };
}

export const BatchInsertResponse = {
  encode(message: BatchInsertResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.count !== 0) {
      writer.uint32(8).uint32(message.count);
    }
    writer.uint32(18).fork();
    for (const v of message.nodeIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchInsertResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchInsertResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = reader.uint32();
          continue;
        case 2:
          if (tag === 16) {
            message.nodeIds.push(reader.uint64() as Long);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.nodeIds.push(reader.uint64() as Long);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchInsertResponse {
    return {
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      nodeIds: globalThis.Array.isArray(object?.nodeIds) ? object.nodeIds.map((e: any) => Long.fromValue(e)) : [],
    };
  },

  toJSON(message: BatchInsertResponse): unknown {
    const obj: any = {};
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.nodeIds?.length) {
      obj.nodeIds = message.nodeIds.map((e) => (e || Long.UZERO).toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchInsertResponse>, I>>(base?: I): BatchInsertResponse {
    return BatchInsertResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchInsertResponse>, I>>(object: I): BatchInsertResponse {
    const message = createBaseBatchInsertResponse();
    message.count = object.count ?? 0;
    message.nodeIds = object.nodeIds?.map((e) => Long.fromValue(e)) || [];
    return message;
  },
};

function createBaseGetNodeRequest(): GetNodeRequest {
  return { nodeId: Long.UZERO };
}

export const GetNodeRequest = {
  encode(message: GetNodeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.nodeId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.nodeId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetNodeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeId = reader.uint64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodeRequest {
    return { nodeId: isSet(object.nodeId) ? Long.fromValue(object.nodeId) : Long.UZERO };
  },

  toJSON(message: GetNodeRequest): unknown {
    const obj: any = {};
    if (!message.nodeId.equals(Long.UZERO)) {
      obj.nodeId = (message.nodeId || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNodeRequest>, I>>(base?: I): GetNodeRequest {
    return GetNodeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNodeRequest>, I>>(object: I): GetNodeRequest {
    const message = createBaseGetNodeRequest();
    message.nodeId = (object.nodeId !== undefined && object.nodeId !== null)
      ? Long.fromValue(object.nodeId)
      : Long.UZERO;
    return message;
  },
};

function createBaseGetNodeResponse(): GetNodeResponse {
  return { node: undefined };
}

export const GetNodeResponse = {
  encode(message: GetNodeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.node !== undefined) {
      Node.encode(message.node, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetNodeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.node = Node.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodeResponse {
    return { node: isSet(object.node) ? Node.fromJSON(object.node) : undefined };
  },

  toJSON(message: GetNodeResponse): unknown {
    const obj: any = {};
    if (message.node !== undefined) {
      obj.node = Node.toJSON(message.node);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNodeResponse>, I>>(base?: I): GetNodeResponse {
    return GetNodeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNodeResponse>, I>>(object: I): GetNodeResponse {
    const message = createBaseGetNodeResponse();
    message.node = (object.node !== undefined && object.node !== null) ? Node.fromPartial(object.node) : undefined;
    return message;
  },
};

function createBaseDeleteNodeRequest(): DeleteNodeRequest {
  return { nodeId: Long.UZERO, sessionId: undefined };
}

export const DeleteNodeRequest = {
  encode(message: DeleteNodeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.nodeId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.nodeId);
    }
    if (message.sessionId !== undefined) {
      writer.uint32(18).string(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteNodeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeId = reader.uint64() as Long;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteNodeRequest {
    return {
      nodeId: isSet(object.nodeId) ? Long.fromValue(object.nodeId) : Long.UZERO,
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : undefined,
    };
  },

  toJSON(message: DeleteNodeRequest): unknown {
    const obj: any = {};
    if (!message.nodeId.equals(Long.UZERO)) {
      obj.nodeId = (message.nodeId || Long.UZERO).toString();
    }
    if (message.sessionId !== undefined) {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteNodeRequest>, I>>(base?: I): DeleteNodeRequest {
    return DeleteNodeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteNodeRequest>, I>>(object: I): DeleteNodeRequest {
    const message = createBaseDeleteNodeRequest();
    message.nodeId = (object.nodeId !== undefined && object.nodeId !== null)
      ? Long.fromValue(object.nodeId)
      : Long.UZERO;
    message.sessionId = object.sessionId ?? undefined;
    return message;
  },
};

function createBaseDeleteNodeResponse(): DeleteNodeResponse {
  return { success: false, message: "" };
}

export const DeleteNodeResponse = {
  encode(message: DeleteNodeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteNodeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteNodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteNodeResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: DeleteNodeResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteNodeResponse>, I>>(base?: I): DeleteNodeResponse {
    return DeleteNodeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteNodeResponse>, I>>(object: I): DeleteNodeResponse {
    const message = createBaseDeleteNodeResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseSearchRequest(): SearchRequest {
  return { queryText: "", userId: Long.UZERO, k: 0, sessionId: undefined, filter: "" };
}

export const SearchRequest = {
  encode(message: SearchRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.queryText !== "") {
      writer.uint32(10).string(message.queryText);
    }
    if (!message.userId.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.userId);
    }
    if (message.k !== 0) {
      writer.uint32(24).uint32(message.k);
    }
    if (message.sessionId !== undefined) {
      writer.uint32(34).string(message.sessionId);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.queryText = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.userId = reader.uint64() as Long;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.k = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest {
    return {
      queryText: isSet(object.queryText) ? globalThis.String(object.queryText) : "",
      userId: isSet(object.userId) ? Long.fromValue(object.userId) : Long.UZERO,
      k: isSet(object.k) ? globalThis.Number(object.k) : 0,
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : undefined,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: SearchRequest): unknown {
    const obj: any = {};
    if (message.queryText !== "") {
      obj.queryText = message.queryText;
    }
    if (!message.userId.equals(Long.UZERO)) {
      obj.userId = (message.userId || Long.UZERO).toString();
    }
    if (message.k !== 0) {
      obj.k = Math.round(message.k);
    }
    if (message.sessionId !== undefined) {
      obj.sessionId = message.sessionId;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchRequest>, I>>(base?: I): SearchRequest {
    return SearchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchRequest>, I>>(object: I): SearchRequest {
    const message = createBaseSearchRequest();
    message.queryText = object.queryText ?? "";
    message.userId = (object.userId !== undefined && object.userId !== null)
      ? Long.fromValue(object.userId)
      : Long.UZERO;
    message.k = object.k ?? 0;
    message.sessionId = object.sessionId ?? undefined;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseSearchResponse(): SearchResponse {
  return { results: [] };
}

export const SearchResponse = {
  encode(message: SearchResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      SearchResult.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(SearchResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => SearchResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => SearchResult.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchResponse>, I>>(base?: I): SearchResponse {
    return SearchResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchResponse>, I>>(object: I): SearchResponse {
    const message = createBaseSearchResponse();
    message.results = object.results?.map((e) => SearchResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchResult(): SearchResult {
  return { id: Long.UZERO, similarity: 0, metadata: Buffer.alloc(0) };
}

export const SearchResult = {
  encode(message: SearchResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.id.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.similarity !== 0) {
      writer.uint32(21).float(message.similarity);
    }
    if (message.metadata.length !== 0) {
      writer.uint32(26).bytes(message.metadata);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64() as Long;
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.similarity = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metadata = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResult {
    return {
      id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO,
      similarity: isSet(object.similarity) ? globalThis.Number(object.similarity) : 0,
      metadata: isSet(object.metadata) ? Buffer.from(bytesFromBase64(object.metadata)) : Buffer.alloc(0),
    };
  },

  toJSON(message: SearchResult): unknown {
    const obj: any = {};
    if (!message.id.equals(Long.UZERO)) {
      obj.id = (message.id || Long.UZERO).toString();
    }
    if (message.similarity !== 0) {
      obj.similarity = message.similarity;
    }
    if (message.metadata.length !== 0) {
      obj.metadata = base64FromBytes(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchResult>, I>>(base?: I): SearchResult {
    return SearchResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchResult>, I>>(object: I): SearchResult {
    const message = createBaseSearchResult();
    message.id = (object.id !== undefined && object.id !== null) ? Long.fromValue(object.id) : Long.UZERO;
    message.similarity = object.similarity ?? 0;
    message.metadata = object.metadata ?? Buffer.alloc(0);
    return message;
  },
};

function createBasePermissions(): Permissions {
  return { read: false, write: false, delete: false };
}

export const Permissions = {
  encode(message: Permissions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.read !== false) {
      writer.uint32(8).bool(message.read);
    }
    if (message.write !== false) {
      writer.uint32(16).bool(message.write);
    }
    if (message.delete !== false) {
      writer.uint32(24).bool(message.delete);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Permissions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.read = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.write = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.delete = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Permissions {
    return {
      read: isSet(object.read) ? globalThis.Boolean(object.read) : false,
      write: isSet(object.write) ? globalThis.Boolean(object.write) : false,
      delete: isSet(object.delete) ? globalThis.Boolean(object.delete) : false,
    };
  },

  toJSON(message: Permissions): unknown {
    const obj: any = {};
    if (message.read !== false) {
      obj.read = message.read;
    }
    if (message.write !== false) {
      obj.write = message.write;
    }
    if (message.delete !== false) {
      obj.delete = message.delete;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Permissions>, I>>(base?: I): Permissions {
    return Permissions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Permissions>, I>>(object: I): Permissions {
    const message = createBasePermissions();
    message.read = object.read ?? false;
    message.write = object.write ?? false;
    message.delete = object.delete ?? false;
    return message;
  },
};

function createBaseGrantPermissionRequest(): GrantPermissionRequest {
  return { nodeId: Long.UZERO, targetUserId: Long.UZERO, permissions: undefined };
}

export const GrantPermissionRequest = {
  encode(message: GrantPermissionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.nodeId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.nodeId);
    }
    if (!message.targetUserId.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.targetUserId);
    }
    if (message.permissions !== undefined) {
      Permissions.encode(message.permissions, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GrantPermissionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrantPermissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeId = reader.uint64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetUserId = reader.uint64() as Long;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.permissions = Permissions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrantPermissionRequest {
    return {
      nodeId: isSet(object.nodeId) ? Long.fromValue(object.nodeId) : Long.UZERO,
      targetUserId: isSet(object.targetUserId) ? Long.fromValue(object.targetUserId) : Long.UZERO,
      permissions: isSet(object.permissions) ? Permissions.fromJSON(object.permissions) : undefined,
    };
  },

  toJSON(message: GrantPermissionRequest): unknown {
    const obj: any = {};
    if (!message.nodeId.equals(Long.UZERO)) {
      obj.nodeId = (message.nodeId || Long.UZERO).toString();
    }
    if (!message.targetUserId.equals(Long.UZERO)) {
      obj.targetUserId = (message.targetUserId || Long.UZERO).toString();
    }
    if (message.permissions !== undefined) {
      obj.permissions = Permissions.toJSON(message.permissions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrantPermissionRequest>, I>>(base?: I): GrantPermissionRequest {
    return GrantPermissionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrantPermissionRequest>, I>>(object: I): GrantPermissionRequest {
    const message = createBaseGrantPermissionRequest();
    message.nodeId = (object.nodeId !== undefined && object.nodeId !== null)
      ? Long.fromValue(object.nodeId)
      : Long.UZERO;
    message.targetUserId = (object.targetUserId !== undefined && object.targetUserId !== null)
      ? Long.fromValue(object.targetUserId)
      : Long.UZERO;
    message.permissions = (object.permissions !== undefined && object.permissions !== null)
      ? Permissions.fromPartial(object.permissions)
      : undefined;
    return message;
  },
};

function createBaseGrantPermissionResponse(): GrantPermissionResponse {
  return { success: false, message: "" };
}

export const GrantPermissionResponse = {
  encode(message: GrantPermissionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GrantPermissionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrantPermissionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrantPermissionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: GrantPermissionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrantPermissionResponse>, I>>(base?: I): GrantPermissionResponse {
    return GrantPermissionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrantPermissionResponse>, I>>(object: I): GrantPermissionResponse {
    const message = createBaseGrantPermissionResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseRevokePermissionRequest(): RevokePermissionRequest {
  return { nodeId: Long.UZERO, targetUserId: Long.UZERO };
}

export const RevokePermissionRequest = {
  encode(message: RevokePermissionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.nodeId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.nodeId);
    }
    if (!message.targetUserId.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.targetUserId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RevokePermissionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokePermissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeId = reader.uint64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetUserId = reader.uint64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokePermissionRequest {
    return {
      nodeId: isSet(object.nodeId) ? Long.fromValue(object.nodeId) : Long.UZERO,
      targetUserId: isSet(object.targetUserId) ? Long.fromValue(object.targetUserId) : Long.UZERO,
    };
  },

  toJSON(message: RevokePermissionRequest): unknown {
    const obj: any = {};
    if (!message.nodeId.equals(Long.UZERO)) {
      obj.nodeId = (message.nodeId || Long.UZERO).toString();
    }
    if (!message.targetUserId.equals(Long.UZERO)) {
      obj.targetUserId = (message.targetUserId || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokePermissionRequest>, I>>(base?: I): RevokePermissionRequest {
    return RevokePermissionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokePermissionRequest>, I>>(object: I): RevokePermissionRequest {
    const message = createBaseRevokePermissionRequest();
    message.nodeId = (object.nodeId !== undefined && object.nodeId !== null)
      ? Long.fromValue(object.nodeId)
      : Long.UZERO;
    message.targetUserId = (object.targetUserId !== undefined && object.targetUserId !== null)
      ? Long.fromValue(object.targetUserId)
      : Long.UZERO;
    return message;
  },
};

function createBaseRevokePermissionResponse(): RevokePermissionResponse {
  return { success: false, message: "" };
}

export const RevokePermissionResponse = {
  encode(message: RevokePermissionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RevokePermissionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokePermissionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokePermissionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: RevokePermissionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokePermissionResponse>, I>>(base?: I): RevokePermissionResponse {
    return RevokePermissionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokePermissionResponse>, I>>(object: I): RevokePermissionResponse {
    const message = createBaseRevokePermissionResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseAddEdgeRequest(): AddEdgeRequest {
  return { from: Long.UZERO, to: Long.UZERO, relation: "", weight: 0 };
}

export const AddEdgeRequest = {
  encode(message: AddEdgeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.from.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.from);
    }
    if (!message.to.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.to);
    }
    if (message.relation !== "") {
      writer.uint32(26).string(message.relation);
    }
    if (message.weight !== 0) {
      writer.uint32(37).float(message.weight);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddEdgeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddEdgeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.from = reader.uint64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.to = reader.uint64() as Long;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.relation = reader.string();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.weight = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddEdgeRequest {
    return {
      from: isSet(object.from) ? Long.fromValue(object.from) : Long.UZERO,
      to: isSet(object.to) ? Long.fromValue(object.to) : Long.UZERO,
      relation: isSet(object.relation) ? globalThis.String(object.relation) : "",
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
    };
  },

  toJSON(message: AddEdgeRequest): unknown {
    const obj: any = {};
    if (!message.from.equals(Long.UZERO)) {
      obj.from = (message.from || Long.UZERO).toString();
    }
    if (!message.to.equals(Long.UZERO)) {
      obj.to = (message.to || Long.UZERO).toString();
    }
    if (message.relation !== "") {
      obj.relation = message.relation;
    }
    if (message.weight !== 0) {
      obj.weight = message.weight;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddEdgeRequest>, I>>(base?: I): AddEdgeRequest {
    return AddEdgeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddEdgeRequest>, I>>(object: I): AddEdgeRequest {
    const message = createBaseAddEdgeRequest();
    message.from = (object.from !== undefined && object.from !== null) ? Long.fromValue(object.from) : Long.UZERO;
    message.to = (object.to !== undefined && object.to !== null) ? Long.fromValue(object.to) : Long.UZERO;
    message.relation = object.relation ?? "";
    message.weight = object.weight ?? 0;
    return message;
  },
};

function createBaseAddEdgeResponse(): AddEdgeResponse {
  return { success: false, message: "" };
}

export const AddEdgeResponse = {
  encode(message: AddEdgeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddEdgeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddEdgeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddEdgeResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: AddEdgeResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddEdgeResponse>, I>>(base?: I): AddEdgeResponse {
    return AddEdgeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddEdgeResponse>, I>>(object: I): AddEdgeResponse {
    const message = createBaseAddEdgeResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseGetNeighborsRequest(): GetNeighborsRequest {
  return { nodeId: Long.UZERO, relation: undefined };
}

export const GetNeighborsRequest = {
  encode(message: GetNeighborsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.nodeId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.nodeId);
    }
    if (message.relation !== undefined) {
      writer.uint32(18).string(message.relation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetNeighborsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNeighborsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeId = reader.uint64() as Long;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.relation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNeighborsRequest {
    return {
      nodeId: isSet(object.nodeId) ? Long.fromValue(object.nodeId) : Long.UZERO,
      relation: isSet(object.relation) ? globalThis.String(object.relation) : undefined,
    };
  },

  toJSON(message: GetNeighborsRequest): unknown {
    const obj: any = {};
    if (!message.nodeId.equals(Long.UZERO)) {
      obj.nodeId = (message.nodeId || Long.UZERO).toString();
    }
    if (message.relation !== undefined) {
      obj.relation = message.relation;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNeighborsRequest>, I>>(base?: I): GetNeighborsRequest {
    return GetNeighborsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNeighborsRequest>, I>>(object: I): GetNeighborsRequest {
    const message = createBaseGetNeighborsRequest();
    message.nodeId = (object.nodeId !== undefined && object.nodeId !== null)
      ? Long.fromValue(object.nodeId)
      : Long.UZERO;
    message.relation = object.relation ?? undefined;
    return message;
  },
};

function createBaseGetNeighborsResponse(): GetNeighborsResponse {
  return { nodeId: Long.UZERO, neighbors: [] };
}

export const GetNeighborsResponse = {
  encode(message: GetNeighborsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.nodeId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.nodeId);
    }
    writer.uint32(18).fork();
    for (const v of message.neighbors) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetNeighborsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNeighborsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeId = reader.uint64() as Long;
          continue;
        case 2:
          if (tag === 16) {
            message.neighbors.push(reader.uint64() as Long);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.neighbors.push(reader.uint64() as Long);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNeighborsResponse {
    return {
      nodeId: isSet(object.nodeId) ? Long.fromValue(object.nodeId) : Long.UZERO,
      neighbors: globalThis.Array.isArray(object?.neighbors) ? object.neighbors.map((e: any) => Long.fromValue(e)) : [],
    };
  },

  toJSON(message: GetNeighborsResponse): unknown {
    const obj: any = {};
    if (!message.nodeId.equals(Long.UZERO)) {
      obj.nodeId = (message.nodeId || Long.UZERO).toString();
    }
    if (message.neighbors?.length) {
      obj.neighbors = message.neighbors.map((e) => (e || Long.UZERO).toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNeighborsResponse>, I>>(base?: I): GetNeighborsResponse {
    return GetNeighborsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNeighborsResponse>, I>>(object: I): GetNeighborsResponse {
    const message = createBaseGetNeighborsResponse();
    message.nodeId = (object.nodeId !== undefined && object.nodeId !== null)
      ? Long.fromValue(object.nodeId)
      : Long.UZERO;
    message.neighbors = object.neighbors?.map((e) => Long.fromValue(e)) || [];
    return message;
  },
};

function createBaseTraverseGraphRequest(): TraverseGraphRequest {
  return { start: Long.UZERO, maxDepth: 0 };
}

export const TraverseGraphRequest = {
  encode(message: TraverseGraphRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.start.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.start);
    }
    if (message.maxDepth !== 0) {
      writer.uint32(16).uint32(message.maxDepth);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TraverseGraphRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraverseGraphRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.start = reader.uint64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxDepth = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraverseGraphRequest {
    return {
      start: isSet(object.start) ? Long.fromValue(object.start) : Long.UZERO,
      maxDepth: isSet(object.maxDepth) ? globalThis.Number(object.maxDepth) : 0,
    };
  },

  toJSON(message: TraverseGraphRequest): unknown {
    const obj: any = {};
    if (!message.start.equals(Long.UZERO)) {
      obj.start = (message.start || Long.UZERO).toString();
    }
    if (message.maxDepth !== 0) {
      obj.maxDepth = Math.round(message.maxDepth);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TraverseGraphRequest>, I>>(base?: I): TraverseGraphRequest {
    return TraverseGraphRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TraverseGraphRequest>, I>>(object: I): TraverseGraphRequest {
    const message = createBaseTraverseGraphRequest();
    message.start = (object.start !== undefined && object.start !== null) ? Long.fromValue(object.start) : Long.UZERO;
    message.maxDepth = object.maxDepth ?? 0;
    return message;
  },
};

function createBaseTraverseGraphResponse(): TraverseGraphResponse {
  return { start: Long.UZERO, visited: [] };
}

export const TraverseGraphResponse = {
  encode(message: TraverseGraphResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.start.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.start);
    }
    writer.uint32(18).fork();
    for (const v of message.visited) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TraverseGraphResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraverseGraphResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.start = reader.uint64() as Long;
          continue;
        case 2:
          if (tag === 16) {
            message.visited.push(reader.uint64() as Long);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.visited.push(reader.uint64() as Long);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraverseGraphResponse {
    return {
      start: isSet(object.start) ? Long.fromValue(object.start) : Long.UZERO,
      visited: globalThis.Array.isArray(object?.visited) ? object.visited.map((e: any) => Long.fromValue(e)) : [],
    };
  },

  toJSON(message: TraverseGraphResponse): unknown {
    const obj: any = {};
    if (!message.start.equals(Long.UZERO)) {
      obj.start = (message.start || Long.UZERO).toString();
    }
    if (message.visited?.length) {
      obj.visited = message.visited.map((e) => (e || Long.UZERO).toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TraverseGraphResponse>, I>>(base?: I): TraverseGraphResponse {
    return TraverseGraphResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TraverseGraphResponse>, I>>(object: I): TraverseGraphResponse {
    const message = createBaseTraverseGraphResponse();
    message.start = (object.start !== undefined && object.start !== null) ? Long.fromValue(object.start) : Long.UZERO;
    message.visited = object.visited?.map((e) => Long.fromValue(e)) || [];
    return message;
  },
};

function createBaseSubscribeRequest(): SubscribeRequest {
  return { filterType: "", nodeId: undefined, vector: [], threshold: undefined, queryText: "" };
}

export const SubscribeRequest = {
  encode(message: SubscribeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filterType !== "") {
      writer.uint32(10).string(message.filterType);
    }
    if (message.nodeId !== undefined) {
      writer.uint32(16).uint64(message.nodeId);
    }
    writer.uint32(26).fork();
    for (const v of message.vector) {
      writer.float(v);
    }
    writer.ldelim();
    if (message.threshold !== undefined) {
      writer.uint32(37).float(message.threshold);
    }
    if (message.queryText !== "") {
      writer.uint32(42).string(message.queryText);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubscribeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filterType = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nodeId = reader.uint64() as Long;
          continue;
        case 3:
          if (tag === 29) {
            message.vector.push(reader.float());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vector.push(reader.float());
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.threshold = reader.float();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.queryText = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeRequest {
    return {
      filterType: isSet(object.filterType) ? globalThis.String(object.filterType) : "",
      nodeId: isSet(object.nodeId) ? Long.fromValue(object.nodeId) : undefined,
      vector: globalThis.Array.isArray(object?.vector) ? object.vector.map((e: any) => globalThis.Number(e)) : [],
      threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : undefined,
      queryText: isSet(object.queryText) ? globalThis.String(object.queryText) : "",
    };
  },

  toJSON(message: SubscribeRequest): unknown {
    const obj: any = {};
    if (message.filterType !== "") {
      obj.filterType = message.filterType;
    }
    if (message.nodeId !== undefined) {
      obj.nodeId = (message.nodeId || Long.UZERO).toString();
    }
    if (message.vector?.length) {
      obj.vector = message.vector;
    }
    if (message.threshold !== undefined) {
      obj.threshold = message.threshold;
    }
    if (message.queryText !== "") {
      obj.queryText = message.queryText;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeRequest>, I>>(base?: I): SubscribeRequest {
    return SubscribeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeRequest>, I>>(object: I): SubscribeRequest {
    const message = createBaseSubscribeRequest();
    message.filterType = object.filterType ?? "";
    message.nodeId = (object.nodeId !== undefined && object.nodeId !== null)
      ? Long.fromValue(object.nodeId)
      : undefined;
    message.vector = object.vector?.map((e) => e) || [];
    message.threshold = object.threshold ?? undefined;
    message.queryText = object.queryText ?? "";
    return message;
  },
};

function createBasePubSubEvent(): PubSubEvent {
  return { type: "", node: undefined, nodeId: Long.UZERO };
}

export const PubSubEvent = {
  encode(message: PubSubEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.node !== undefined) {
      Node.encode(message.node, writer.uint32(18).fork()).ldelim();
    }
    if (!message.nodeId.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.nodeId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PubSubEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubSubEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.node = Node.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.nodeId = reader.uint64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubSubEvent {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      node: isSet(object.node) ? Node.fromJSON(object.node) : undefined,
      nodeId: isSet(object.nodeId) ? Long.fromValue(object.nodeId) : Long.UZERO,
    };
  },

  toJSON(message: PubSubEvent): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.node !== undefined) {
      obj.node = Node.toJSON(message.node);
    }
    if (!message.nodeId.equals(Long.UZERO)) {
      obj.nodeId = (message.nodeId || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PubSubEvent>, I>>(base?: I): PubSubEvent {
    return PubSubEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PubSubEvent>, I>>(object: I): PubSubEvent {
    const message = createBasePubSubEvent();
    message.type = object.type ?? "";
    message.node = (object.node !== undefined && object.node !== null) ? Node.fromPartial(object.node) : undefined;
    message.nodeId = (object.nodeId !== undefined && object.nodeId !== null)
      ? Long.fromValue(object.nodeId)
      : Long.UZERO;
    return message;
  },
};

function createBaseBitVector(): BitVector {
  return { chunks: [] };
}

export const BitVector = {
  encode(message: BitVector, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.chunks) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BitVector {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBitVector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.chunks.push(reader.uint64() as Long);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.chunks.push(reader.uint64() as Long);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BitVector {
    return { chunks: globalThis.Array.isArray(object?.chunks) ? object.chunks.map((e: any) => Long.fromValue(e)) : [] };
  },

  toJSON(message: BitVector): unknown {
    const obj: any = {};
    if (message.chunks?.length) {
      obj.chunks = message.chunks.map((e) => (e || Long.UZERO).toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BitVector>, I>>(base?: I): BitVector {
    return BitVector.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BitVector>, I>>(object: I): BitVector {
    const message = createBaseBitVector();
    message.chunks = object.chunks?.map((e) => Long.fromValue(e)) || [];
    return message;
  },
};

function createBaseWriteMemoryRequest(): WriteMemoryRequest {
  return { address: undefined, data: undefined, userId: Long.UZERO };
}

export const WriteMemoryRequest = {
  encode(message: WriteMemoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== undefined) {
      BitVector.encode(message.address, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== undefined) {
      BitVector.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    if (!message.userId.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.userId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WriteMemoryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteMemoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = BitVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = BitVector.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.userId = reader.uint64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteMemoryRequest {
    return {
      address: isSet(object.address) ? BitVector.fromJSON(object.address) : undefined,
      data: isSet(object.data) ? BitVector.fromJSON(object.data) : undefined,
      userId: isSet(object.userId) ? Long.fromValue(object.userId) : Long.UZERO,
    };
  },

  toJSON(message: WriteMemoryRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = BitVector.toJSON(message.address);
    }
    if (message.data !== undefined) {
      obj.data = BitVector.toJSON(message.data);
    }
    if (!message.userId.equals(Long.UZERO)) {
      obj.userId = (message.userId || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WriteMemoryRequest>, I>>(base?: I): WriteMemoryRequest {
    return WriteMemoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WriteMemoryRequest>, I>>(object: I): WriteMemoryRequest {
    const message = createBaseWriteMemoryRequest();
    message.address = (object.address !== undefined && object.address !== null)
      ? BitVector.fromPartial(object.address)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null) ? BitVector.fromPartial(object.data) : undefined;
    message.userId = (object.userId !== undefined && object.userId !== null)
      ? Long.fromValue(object.userId)
      : Long.UZERO;
    return message;
  },
};

function createBaseWriteMemoryResponse(): WriteMemoryResponse {
  return { success: false, message: "" };
}

export const WriteMemoryResponse = {
  encode(message: WriteMemoryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WriteMemoryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteMemoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteMemoryResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: WriteMemoryResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WriteMemoryResponse>, I>>(base?: I): WriteMemoryResponse {
    return WriteMemoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WriteMemoryResponse>, I>>(object: I): WriteMemoryResponse {
    const message = createBaseWriteMemoryResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseReadMemoryRequest(): ReadMemoryRequest {
  return { address: undefined, userId: Long.UZERO };
}

export const ReadMemoryRequest = {
  encode(message: ReadMemoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== undefined) {
      BitVector.encode(message.address, writer.uint32(10).fork()).ldelim();
    }
    if (!message.userId.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.userId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReadMemoryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadMemoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = BitVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.userId = reader.uint64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadMemoryRequest {
    return {
      address: isSet(object.address) ? BitVector.fromJSON(object.address) : undefined,
      userId: isSet(object.userId) ? Long.fromValue(object.userId) : Long.UZERO,
    };
  },

  toJSON(message: ReadMemoryRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = BitVector.toJSON(message.address);
    }
    if (!message.userId.equals(Long.UZERO)) {
      obj.userId = (message.userId || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadMemoryRequest>, I>>(base?: I): ReadMemoryRequest {
    return ReadMemoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadMemoryRequest>, I>>(object: I): ReadMemoryRequest {
    const message = createBaseReadMemoryRequest();
    message.address = (object.address !== undefined && object.address !== null)
      ? BitVector.fromPartial(object.address)
      : undefined;
    message.userId = (object.userId !== undefined && object.userId !== null)
      ? Long.fromValue(object.userId)
      : Long.UZERO;
    return message;
  },
};

function createBaseReadMemoryResponse(): ReadMemoryResponse {
  return { data: undefined };
}

export const ReadMemoryResponse = {
  encode(message: ReadMemoryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data !== undefined) {
      BitVector.encode(message.data, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReadMemoryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadMemoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = BitVector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadMemoryResponse {
    return { data: isSet(object.data) ? BitVector.fromJSON(object.data) : undefined };
  },

  toJSON(message: ReadMemoryResponse): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = BitVector.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadMemoryResponse>, I>>(base?: I): ReadMemoryResponse {
    return ReadMemoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadMemoryResponse>, I>>(object: I): ReadMemoryResponse {
    const message = createBaseReadMemoryResponse();
    message.data = (object.data !== undefined && object.data !== null) ? BitVector.fromPartial(object.data) : undefined;
    return message;
  },
};

function createBaseMemoryEntry(): MemoryEntry {
  return { id: "", sessionId: "", agentId: "", content: "", timestamp: Long.ZERO, metadata: {}, expiresAt: undefined };
}

export const MemoryEntry = {
  encode(message: MemoryEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.agentId !== "") {
      writer.uint32(26).string(message.agentId);
    }
    if (message.content !== "") {
      writer.uint32(34).string(message.content);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.timestamp);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      MemoryEntry_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).ldelim();
    });
    if (message.expiresAt !== undefined) {
      writer.uint32(56).int64(message.expiresAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MemoryEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.agentId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.content = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.timestamp = reader.int64() as Long;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = MemoryEntry_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.expiresAt = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoryEntry {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      agentId: isSet(object.agentId) ? globalThis.String(object.agentId) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.ZERO,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      expiresAt: isSet(object.expiresAt) ? Long.fromValue(object.expiresAt) : undefined,
    };
  },

  toJSON(message: MemoryEntry): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.agentId !== "") {
      obj.agentId = message.agentId;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = (message.expiresAt || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryEntry>, I>>(base?: I): MemoryEntry {
    return MemoryEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemoryEntry>, I>>(object: I): MemoryEntry {
    const message = createBaseMemoryEntry();
    message.id = object.id ?? "";
    message.sessionId = object.sessionId ?? "";
    message.agentId = object.agentId ?? "";
    message.content = object.content ?? "";
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.ZERO;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.expiresAt = (object.expiresAt !== undefined && object.expiresAt !== null)
      ? Long.fromValue(object.expiresAt)
      : undefined;
    return message;
  },
};

function createBaseMemoryEntry_MetadataEntry(): MemoryEntry_MetadataEntry {
  return { key: "", value: "" };
}

export const MemoryEntry_MetadataEntry = {
  encode(message: MemoryEntry_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MemoryEntry_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryEntry_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoryEntry_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MemoryEntry_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryEntry_MetadataEntry>, I>>(base?: I): MemoryEntry_MetadataEntry {
    return MemoryEntry_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemoryEntry_MetadataEntry>, I>>(object: I): MemoryEntry_MetadataEntry {
    const message = createBaseMemoryEntry_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAddMemoryRequest(): AddMemoryRequest {
  return { sessionId: "", agentId: "", content: "", metadata: {}, ttlSeconds: undefined };
}

export const AddMemoryRequest = {
  encode(message: AddMemoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.agentId !== "") {
      writer.uint32(18).string(message.agentId);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      AddMemoryRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    if (message.ttlSeconds !== undefined) {
      writer.uint32(40).int64(message.ttlSeconds);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddMemoryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddMemoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.agentId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = AddMemoryRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.ttlSeconds = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddMemoryRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      agentId: isSet(object.agentId) ? globalThis.String(object.agentId) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      ttlSeconds: isSet(object.ttlSeconds) ? Long.fromValue(object.ttlSeconds) : undefined,
    };
  },

  toJSON(message: AddMemoryRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.agentId !== "") {
      obj.agentId = message.agentId;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.ttlSeconds !== undefined) {
      obj.ttlSeconds = (message.ttlSeconds || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddMemoryRequest>, I>>(base?: I): AddMemoryRequest {
    return AddMemoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddMemoryRequest>, I>>(object: I): AddMemoryRequest {
    const message = createBaseAddMemoryRequest();
    message.sessionId = object.sessionId ?? "";
    message.agentId = object.agentId ?? "";
    message.content = object.content ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.ttlSeconds = (object.ttlSeconds !== undefined && object.ttlSeconds !== null)
      ? Long.fromValue(object.ttlSeconds)
      : undefined;
    return message;
  },
};

function createBaseAddMemoryRequest_MetadataEntry(): AddMemoryRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const AddMemoryRequest_MetadataEntry = {
  encode(message: AddMemoryRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddMemoryRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddMemoryRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddMemoryRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AddMemoryRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddMemoryRequest_MetadataEntry>, I>>(base?: I): AddMemoryRequest_MetadataEntry {
    return AddMemoryRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddMemoryRequest_MetadataEntry>, I>>(
    object: I,
  ): AddMemoryRequest_MetadataEntry {
    const message = createBaseAddMemoryRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAddMemoryResponse(): AddMemoryResponse {
  return { success: false, message: "", entry: undefined };
}

export const AddMemoryResponse = {
  encode(message: AddMemoryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.entry !== undefined) {
      MemoryEntry.encode(message.entry, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddMemoryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddMemoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entry = MemoryEntry.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddMemoryResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      entry: isSet(object.entry) ? MemoryEntry.fromJSON(object.entry) : undefined,
    };
  },

  toJSON(message: AddMemoryResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.entry !== undefined) {
      obj.entry = MemoryEntry.toJSON(message.entry);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddMemoryResponse>, I>>(base?: I): AddMemoryResponse {
    return AddMemoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddMemoryResponse>, I>>(object: I): AddMemoryResponse {
    const message = createBaseAddMemoryResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.entry = (object.entry !== undefined && object.entry !== null)
      ? MemoryEntry.fromPartial(object.entry)
      : undefined;
    return message;
  },
};

function createBaseGetMemoryRequest(): GetMemoryRequest {
  return { sessionId: "", limit: 0, afterTimestamp: Long.ZERO, filter: {} };
}

export const GetMemoryRequest = {
  encode(message: GetMemoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.limit !== 0) {
      writer.uint32(16).uint32(message.limit);
    }
    if (!message.afterTimestamp.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.afterTimestamp);
    }
    Object.entries(message.filter).forEach(([key, value]) => {
      GetMemoryRequest_FilterEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMemoryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMemoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.afterTimestamp = reader.int64() as Long;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = GetMemoryRequest_FilterEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.filter[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMemoryRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      afterTimestamp: isSet(object.afterTimestamp) ? Long.fromValue(object.afterTimestamp) : Long.ZERO,
      filter: isObject(object.filter)
        ? Object.entries(object.filter).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetMemoryRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (!message.afterTimestamp.equals(Long.ZERO)) {
      obj.afterTimestamp = (message.afterTimestamp || Long.ZERO).toString();
    }
    if (message.filter) {
      const entries = Object.entries(message.filter);
      if (entries.length > 0) {
        obj.filter = {};
        entries.forEach(([k, v]) => {
          obj.filter[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMemoryRequest>, I>>(base?: I): GetMemoryRequest {
    return GetMemoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMemoryRequest>, I>>(object: I): GetMemoryRequest {
    const message = createBaseGetMemoryRequest();
    message.sessionId = object.sessionId ?? "";
    message.limit = object.limit ?? 0;
    message.afterTimestamp = (object.afterTimestamp !== undefined && object.afterTimestamp !== null)
      ? Long.fromValue(object.afterTimestamp)
      : Long.ZERO;
    message.filter = Object.entries(object.filter ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetMemoryRequest_FilterEntry(): GetMemoryRequest_FilterEntry {
  return { key: "", value: "" };
}

export const GetMemoryRequest_FilterEntry = {
  encode(message: GetMemoryRequest_FilterEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMemoryRequest_FilterEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMemoryRequest_FilterEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMemoryRequest_FilterEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GetMemoryRequest_FilterEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMemoryRequest_FilterEntry>, I>>(base?: I): GetMemoryRequest_FilterEntry {
    return GetMemoryRequest_FilterEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMemoryRequest_FilterEntry>, I>>(object: I): GetMemoryRequest_FilterEntry {
    const message = createBaseGetMemoryRequest_FilterEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetMemoryResponse(): GetMemoryResponse {
  return { entries: [] };
}

export const GetMemoryResponse = {
  encode(message: GetMemoryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.entries) {
      MemoryEntry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMemoryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMemoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(MemoryEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMemoryResponse {
    return {
      entries: globalThis.Array.isArray(object?.entries) ? object.entries.map((e: any) => MemoryEntry.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetMemoryResponse): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => MemoryEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMemoryResponse>, I>>(base?: I): GetMemoryResponse {
    return GetMemoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMemoryResponse>, I>>(object: I): GetMemoryResponse {
    const message = createBaseGetMemoryResponse();
    message.entries = object.entries?.map((e) => MemoryEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClearMemoryRequest(): ClearMemoryRequest {
  return { sessionId: "" };
}

export const ClearMemoryRequest = {
  encode(message: ClearMemoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClearMemoryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClearMemoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClearMemoryRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "" };
  },

  toJSON(message: ClearMemoryRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClearMemoryRequest>, I>>(base?: I): ClearMemoryRequest {
    return ClearMemoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClearMemoryRequest>, I>>(object: I): ClearMemoryRequest {
    const message = createBaseClearMemoryRequest();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseClearMemoryResponse(): ClearMemoryResponse {
  return { success: false, message: "" };
}

export const ClearMemoryResponse = {
  encode(message: ClearMemoryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClearMemoryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClearMemoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClearMemoryResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ClearMemoryResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClearMemoryResponse>, I>>(base?: I): ClearMemoryResponse {
    return ClearMemoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClearMemoryResponse>, I>>(object: I): ClearMemoryResponse {
    const message = createBaseClearMemoryResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseWatchMemoryRequest(): WatchMemoryRequest {
  return { sessionId: "" };
}

export const WatchMemoryRequest = {
  encode(message: WatchMemoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WatchMemoryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWatchMemoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WatchMemoryRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "" };
  },

  toJSON(message: WatchMemoryRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WatchMemoryRequest>, I>>(base?: I): WatchMemoryRequest {
    return WatchMemoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WatchMemoryRequest>, I>>(object: I): WatchMemoryRequest {
    const message = createBaseWatchMemoryRequest();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseMemoryEvent(): MemoryEvent {
  return { type: "", entry: undefined };
}

export const MemoryEvent = {
  encode(message: MemoryEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.entry !== undefined) {
      MemoryEntry.encode(message.entry, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MemoryEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entry = MemoryEntry.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoryEvent {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      entry: isSet(object.entry) ? MemoryEntry.fromJSON(object.entry) : undefined,
    };
  },

  toJSON(message: MemoryEvent): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.entry !== undefined) {
      obj.entry = MemoryEntry.toJSON(message.entry);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryEvent>, I>>(base?: I): MemoryEvent {
    return MemoryEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemoryEvent>, I>>(object: I): MemoryEvent {
    const message = createBaseMemoryEvent();
    message.type = object.type ?? "";
    message.entry = (object.entry !== undefined && object.entry !== null)
      ? MemoryEntry.fromPartial(object.entry)
      : undefined;
    return message;
  },
};

function createBaseCreateSessionRequest(): CreateSessionRequest {
  return { parentSessionId: undefined };
}

export const CreateSessionRequest = {
  encode(message: CreateSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.parentSessionId !== undefined) {
      writer.uint32(10).string(message.parentSessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parentSessionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionRequest {
    return { parentSessionId: isSet(object.parentSessionId) ? globalThis.String(object.parentSessionId) : undefined };
  },

  toJSON(message: CreateSessionRequest): unknown {
    const obj: any = {};
    if (message.parentSessionId !== undefined) {
      obj.parentSessionId = message.parentSessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionRequest>, I>>(base?: I): CreateSessionRequest {
    return CreateSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionRequest>, I>>(object: I): CreateSessionRequest {
    const message = createBaseCreateSessionRequest();
    message.parentSessionId = object.parentSessionId ?? undefined;
    return message;
  },
};

function createBaseCreateSessionResponse(): CreateSessionResponse {
  return { sessionId: "" };
}

export const CreateSessionResponse = {
  encode(message: CreateSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionResponse {
    return { sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "" };
  },

  toJSON(message: CreateSessionResponse): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionResponse>, I>>(base?: I): CreateSessionResponse {
    return CreateSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionResponse>, I>>(object: I): CreateSessionResponse {
    const message = createBaseCreateSessionResponse();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseSnapshotSessionRequest(): SnapshotSessionRequest {
  return { sessionId: "", path: "" };
}

export const SnapshotSessionRequest = {
  encode(message: SnapshotSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SnapshotSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSnapshotSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SnapshotSessionRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: SnapshotSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SnapshotSessionRequest>, I>>(base?: I): SnapshotSessionRequest {
    return SnapshotSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SnapshotSessionRequest>, I>>(object: I): SnapshotSessionRequest {
    const message = createBaseSnapshotSessionRequest();
    message.sessionId = object.sessionId ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseSnapshotSessionResponse(): SnapshotSessionResponse {
  return { success: false };
}

export const SnapshotSessionResponse = {
  encode(message: SnapshotSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SnapshotSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSnapshotSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SnapshotSessionResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: SnapshotSessionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SnapshotSessionResponse>, I>>(base?: I): SnapshotSessionResponse {
    return SnapshotSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SnapshotSessionResponse>, I>>(object: I): SnapshotSessionResponse {
    const message = createBaseSnapshotSessionResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseLoadSessionRequest(): LoadSessionRequest {
  return { path: "" };
}

export const LoadSessionRequest = {
  encode(message: LoadSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoadSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadSessionRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: LoadSessionRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadSessionRequest>, I>>(base?: I): LoadSessionRequest {
    return LoadSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadSessionRequest>, I>>(object: I): LoadSessionRequest {
    const message = createBaseLoadSessionRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseLoadSessionResponse(): LoadSessionResponse {
  return { sessionId: "" };
}

export const LoadSessionResponse = {
  encode(message: LoadSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoadSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadSessionResponse {
    return { sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "" };
  },

  toJSON(message: LoadSessionResponse): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadSessionResponse>, I>>(base?: I): LoadSessionResponse {
    return LoadSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadSessionResponse>, I>>(object: I): LoadSessionResponse {
    const message = createBaseLoadSessionResponse();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseCommitSessionRequest(): CommitSessionRequest {
  return { sessionId: "", mergeStrategy: "" };
}

export const CommitSessionRequest = {
  encode(message: CommitSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.mergeStrategy !== "") {
      writer.uint32(18).string(message.mergeStrategy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CommitSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mergeStrategy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitSessionRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      mergeStrategy: isSet(object.mergeStrategy) ? globalThis.String(object.mergeStrategy) : "",
    };
  },

  toJSON(message: CommitSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.mergeStrategy !== "") {
      obj.mergeStrategy = message.mergeStrategy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommitSessionRequest>, I>>(base?: I): CommitSessionRequest {
    return CommitSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommitSessionRequest>, I>>(object: I): CommitSessionRequest {
    const message = createBaseCommitSessionRequest();
    message.sessionId = object.sessionId ?? "";
    message.mergeStrategy = object.mergeStrategy ?? "";
    return message;
  },
};

function createBaseCommitSessionResponse(): CommitSessionResponse {
  return { success: false };
}

export const CommitSessionResponse = {
  encode(message: CommitSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CommitSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitSessionResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: CommitSessionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommitSessionResponse>, I>>(base?: I): CommitSessionResponse {
    return CommitSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommitSessionResponse>, I>>(object: I): CommitSessionResponse {
    const message = createBaseCommitSessionResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseDropSessionRequest(): DropSessionRequest {
  return { sessionId: "" };
}

export const DropSessionRequest = {
  encode(message: DropSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DropSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDropSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DropSessionRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "" };
  },

  toJSON(message: DropSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DropSessionRequest>, I>>(base?: I): DropSessionRequest {
    return DropSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DropSessionRequest>, I>>(object: I): DropSessionRequest {
    const message = createBaseDropSessionRequest();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseDropSessionResponse(): DropSessionResponse {
  return { success: false };
}

export const DropSessionResponse = {
  encode(message: DropSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DropSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDropSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DropSessionResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DropSessionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DropSessionResponse>, I>>(base?: I): DropSessionResponse {
    return DropSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DropSessionResponse>, I>>(object: I): DropSessionResponse {
    const message = createBaseDropSessionResponse();
    message.success = object.success ?? false;
    return message;
  },
};

/** RiceDB gRPC service definition */
export type RiceDBService = typeof RiceDBService;
export const RiceDBService = {
  /** Login */
  login: {
    path: "/ricedb.RiceDB/Login",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LoginRequest) => Buffer.from(LoginRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => LoginRequest.decode(value),
    responseSerialize: (value: LoginResponse) => Buffer.from(LoginResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => LoginResponse.decode(value),
  },
  /** Create User (Admin only) */
  createUser: {
    path: "/ricedb.RiceDB/CreateUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateUserRequest) => Buffer.from(CreateUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateUserRequest.decode(value),
    responseSerialize: (value: CreateUserResponse) => Buffer.from(CreateUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateUserResponse.decode(value),
  },
  /** Delete User (Admin only) */
  deleteUser: {
    path: "/ricedb.RiceDB/DeleteUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteUserRequest) => Buffer.from(DeleteUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteUserRequest.decode(value),
    responseSerialize: (value: DeleteUserResponse) => Buffer.from(DeleteUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteUserResponse.decode(value),
  },
  /** Health check */
  health: {
    path: "/ricedb.RiceDB/Health",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HealthRequest) => Buffer.from(HealthRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => HealthRequest.decode(value),
    responseSerialize: (value: HealthResponse) => Buffer.from(HealthResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthResponse.decode(value),
  },
  /** Insert a document */
  insert: {
    path: "/ricedb.RiceDB/Insert",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: InsertRequest) => Buffer.from(InsertRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => InsertRequest.decode(value),
    responseSerialize: (value: InsertResponse) => Buffer.from(InsertResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => InsertResponse.decode(value),
  },
  /** Get a document */
  getNode: {
    path: "/ricedb.RiceDB/GetNode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetNodeRequest) => Buffer.from(GetNodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetNodeRequest.decode(value),
    responseSerialize: (value: GetNodeResponse) => Buffer.from(GetNodeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetNodeResponse.decode(value),
  },
  /** Delete a document */
  deleteNode: {
    path: "/ricedb.RiceDB/DeleteNode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteNodeRequest) => Buffer.from(DeleteNodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteNodeRequest.decode(value),
    responseSerialize: (value: DeleteNodeResponse) => Buffer.from(DeleteNodeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteNodeResponse.decode(value),
  },
  /** Search for similar documents */
  search: {
    path: "/ricedb.RiceDB/Search",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SearchRequest) => Buffer.from(SearchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SearchRequest.decode(value),
    responseSerialize: (value: SearchResponse) => Buffer.from(SearchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SearchResponse.decode(value),
  },
  /** Batch insert (streaming) */
  batchInsert: {
    path: "/ricedb.RiceDB/BatchInsert",
    requestStream: true,
    responseStream: false,
    requestSerialize: (value: InsertRequest) => Buffer.from(InsertRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => InsertRequest.decode(value),
    responseSerialize: (value: BatchInsertResponse) => Buffer.from(BatchInsertResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BatchInsertResponse.decode(value),
  },
  /** Streaming search results */
  streamSearch: {
    path: "/ricedb.RiceDB/StreamSearch",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: SearchRequest) => Buffer.from(SearchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SearchRequest.decode(value),
    responseSerialize: (value: SearchResult) => Buffer.from(SearchResult.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SearchResult.decode(value),
  },
  /** ACL Operations */
  grantPermission: {
    path: "/ricedb.RiceDB/GrantPermission",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GrantPermissionRequest) => Buffer.from(GrantPermissionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GrantPermissionRequest.decode(value),
    responseSerialize: (value: GrantPermissionResponse) => Buffer.from(GrantPermissionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GrantPermissionResponse.decode(value),
  },
  revokePermission: {
    path: "/ricedb.RiceDB/RevokePermission",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RevokePermissionRequest) => Buffer.from(RevokePermissionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RevokePermissionRequest.decode(value),
    responseSerialize: (value: RevokePermissionResponse) =>
      Buffer.from(RevokePermissionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RevokePermissionResponse.decode(value),
  },
  /** Graph Operations */
  addEdge: {
    path: "/ricedb.RiceDB/AddEdge",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AddEdgeRequest) => Buffer.from(AddEdgeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AddEdgeRequest.decode(value),
    responseSerialize: (value: AddEdgeResponse) => Buffer.from(AddEdgeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AddEdgeResponse.decode(value),
  },
  getNeighbors: {
    path: "/ricedb.RiceDB/GetNeighbors",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetNeighborsRequest) => Buffer.from(GetNeighborsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetNeighborsRequest.decode(value),
    responseSerialize: (value: GetNeighborsResponse) => Buffer.from(GetNeighborsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetNeighborsResponse.decode(value),
  },
  traverseGraph: {
    path: "/ricedb.RiceDB/TraverseGraph",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TraverseGraphRequest) => Buffer.from(TraverseGraphRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TraverseGraphRequest.decode(value),
    responseSerialize: (value: TraverseGraphResponse) => Buffer.from(TraverseGraphResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TraverseGraphResponse.decode(value),
  },
  /** PubSub */
  subscribe: {
    path: "/ricedb.RiceDB/Subscribe",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: SubscribeRequest) => Buffer.from(SubscribeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SubscribeRequest.decode(value),
    responseSerialize: (value: PubSubEvent) => Buffer.from(PubSubEvent.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PubSubEvent.decode(value),
  },
  /** SDM Write */
  writeMemory: {
    path: "/ricedb.RiceDB/WriteMemory",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WriteMemoryRequest) => Buffer.from(WriteMemoryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => WriteMemoryRequest.decode(value),
    responseSerialize: (value: WriteMemoryResponse) => Buffer.from(WriteMemoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => WriteMemoryResponse.decode(value),
  },
  /** SDM Read */
  readMemory: {
    path: "/ricedb.RiceDB/ReadMemory",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ReadMemoryRequest) => Buffer.from(ReadMemoryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ReadMemoryRequest.decode(value),
    responseSerialize: (value: ReadMemoryResponse) => Buffer.from(ReadMemoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ReadMemoryResponse.decode(value),
  },
  /** Agent Memory (Scratchpad) */
  addMemory: {
    path: "/ricedb.RiceDB/AddMemory",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AddMemoryRequest) => Buffer.from(AddMemoryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AddMemoryRequest.decode(value),
    responseSerialize: (value: AddMemoryResponse) => Buffer.from(AddMemoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AddMemoryResponse.decode(value),
  },
  getMemory: {
    path: "/ricedb.RiceDB/GetMemory",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMemoryRequest) => Buffer.from(GetMemoryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetMemoryRequest.decode(value),
    responseSerialize: (value: GetMemoryResponse) => Buffer.from(GetMemoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetMemoryResponse.decode(value),
  },
  clearMemory: {
    path: "/ricedb.RiceDB/ClearMemory",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ClearMemoryRequest) => Buffer.from(ClearMemoryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ClearMemoryRequest.decode(value),
    responseSerialize: (value: ClearMemoryResponse) => Buffer.from(ClearMemoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ClearMemoryResponse.decode(value),
  },
  watchMemory: {
    path: "/ricedb.RiceDB/WatchMemory",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: WatchMemoryRequest) => Buffer.from(WatchMemoryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => WatchMemoryRequest.decode(value),
    responseSerialize: (value: MemoryEvent) => Buffer.from(MemoryEvent.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MemoryEvent.decode(value),
  },
  /** Cortex Session Operations */
  createSession: {
    path: "/ricedb.RiceDB/CreateSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateSessionRequest) => Buffer.from(CreateSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateSessionRequest.decode(value),
    responseSerialize: (value: CreateSessionResponse) => Buffer.from(CreateSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateSessionResponse.decode(value),
  },
  snapshotSession: {
    path: "/ricedb.RiceDB/SnapshotSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SnapshotSessionRequest) => Buffer.from(SnapshotSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SnapshotSessionRequest.decode(value),
    responseSerialize: (value: SnapshotSessionResponse) => Buffer.from(SnapshotSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SnapshotSessionResponse.decode(value),
  },
  loadSession: {
    path: "/ricedb.RiceDB/LoadSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LoadSessionRequest) => Buffer.from(LoadSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => LoadSessionRequest.decode(value),
    responseSerialize: (value: LoadSessionResponse) => Buffer.from(LoadSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => LoadSessionResponse.decode(value),
  },
  commitSession: {
    path: "/ricedb.RiceDB/CommitSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CommitSessionRequest) => Buffer.from(CommitSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CommitSessionRequest.decode(value),
    responseSerialize: (value: CommitSessionResponse) => Buffer.from(CommitSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CommitSessionResponse.decode(value),
  },
  dropSession: {
    path: "/ricedb.RiceDB/DropSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DropSessionRequest) => Buffer.from(DropSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DropSessionRequest.decode(value),
    responseSerialize: (value: DropSessionResponse) => Buffer.from(DropSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DropSessionResponse.decode(value),
  },
} as const;

export interface RiceDBServer extends UntypedServiceImplementation {
  /** Login */
  login: handleUnaryCall<LoginRequest, LoginResponse>;
  /** Create User (Admin only) */
  createUser: handleUnaryCall<CreateUserRequest, CreateUserResponse>;
  /** Delete User (Admin only) */
  deleteUser: handleUnaryCall<DeleteUserRequest, DeleteUserResponse>;
  /** Health check */
  health: handleUnaryCall<HealthRequest, HealthResponse>;
  /** Insert a document */
  insert: handleUnaryCall<InsertRequest, InsertResponse>;
  /** Get a document */
  getNode: handleUnaryCall<GetNodeRequest, GetNodeResponse>;
  /** Delete a document */
  deleteNode: handleUnaryCall<DeleteNodeRequest, DeleteNodeResponse>;
  /** Search for similar documents */
  search: handleUnaryCall<SearchRequest, SearchResponse>;
  /** Batch insert (streaming) */
  batchInsert: handleClientStreamingCall<InsertRequest, BatchInsertResponse>;
  /** Streaming search results */
  streamSearch: handleServerStreamingCall<SearchRequest, SearchResult>;
  /** ACL Operations */
  grantPermission: handleUnaryCall<GrantPermissionRequest, GrantPermissionResponse>;
  revokePermission: handleUnaryCall<RevokePermissionRequest, RevokePermissionResponse>;
  /** Graph Operations */
  addEdge: handleUnaryCall<AddEdgeRequest, AddEdgeResponse>;
  getNeighbors: handleUnaryCall<GetNeighborsRequest, GetNeighborsResponse>;
  traverseGraph: handleUnaryCall<TraverseGraphRequest, TraverseGraphResponse>;
  /** PubSub */
  subscribe: handleServerStreamingCall<SubscribeRequest, PubSubEvent>;
  /** SDM Write */
  writeMemory: handleUnaryCall<WriteMemoryRequest, WriteMemoryResponse>;
  /** SDM Read */
  readMemory: handleUnaryCall<ReadMemoryRequest, ReadMemoryResponse>;
  /** Agent Memory (Scratchpad) */
  addMemory: handleUnaryCall<AddMemoryRequest, AddMemoryResponse>;
  getMemory: handleUnaryCall<GetMemoryRequest, GetMemoryResponse>;
  clearMemory: handleUnaryCall<ClearMemoryRequest, ClearMemoryResponse>;
  watchMemory: handleServerStreamingCall<WatchMemoryRequest, MemoryEvent>;
  /** Cortex Session Operations */
  createSession: handleUnaryCall<CreateSessionRequest, CreateSessionResponse>;
  snapshotSession: handleUnaryCall<SnapshotSessionRequest, SnapshotSessionResponse>;
  loadSession: handleUnaryCall<LoadSessionRequest, LoadSessionResponse>;
  commitSession: handleUnaryCall<CommitSessionRequest, CommitSessionResponse>;
  dropSession: handleUnaryCall<DropSessionRequest, DropSessionResponse>;
}

export interface RiceDBClient extends Client {
  /** Login */
  login(
    request: LoginRequest,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  login(
    request: LoginRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  login(
    request: LoginRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  /** Create User (Admin only) */
  createUser(
    request: CreateUserRequest,
    callback: (error: ServiceError | null, response: CreateUserResponse) => void,
  ): ClientUnaryCall;
  createUser(
    request: CreateUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateUserResponse) => void,
  ): ClientUnaryCall;
  createUser(
    request: CreateUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateUserResponse) => void,
  ): ClientUnaryCall;
  /** Delete User (Admin only) */
  deleteUser(
    request: DeleteUserRequest,
    callback: (error: ServiceError | null, response: DeleteUserResponse) => void,
  ): ClientUnaryCall;
  deleteUser(
    request: DeleteUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteUserResponse) => void,
  ): ClientUnaryCall;
  deleteUser(
    request: DeleteUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteUserResponse) => void,
  ): ClientUnaryCall;
  /** Health check */
  health(
    request: HealthRequest,
    callback: (error: ServiceError | null, response: HealthResponse) => void,
  ): ClientUnaryCall;
  health(
    request: HealthRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: HealthResponse) => void,
  ): ClientUnaryCall;
  health(
    request: HealthRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: HealthResponse) => void,
  ): ClientUnaryCall;
  /** Insert a document */
  insert(
    request: InsertRequest,
    callback: (error: ServiceError | null, response: InsertResponse) => void,
  ): ClientUnaryCall;
  insert(
    request: InsertRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: InsertResponse) => void,
  ): ClientUnaryCall;
  insert(
    request: InsertRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: InsertResponse) => void,
  ): ClientUnaryCall;
  /** Get a document */
  getNode(
    request: GetNodeRequest,
    callback: (error: ServiceError | null, response: GetNodeResponse) => void,
  ): ClientUnaryCall;
  getNode(
    request: GetNodeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetNodeResponse) => void,
  ): ClientUnaryCall;
  getNode(
    request: GetNodeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetNodeResponse) => void,
  ): ClientUnaryCall;
  /** Delete a document */
  deleteNode(
    request: DeleteNodeRequest,
    callback: (error: ServiceError | null, response: DeleteNodeResponse) => void,
  ): ClientUnaryCall;
  deleteNode(
    request: DeleteNodeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteNodeResponse) => void,
  ): ClientUnaryCall;
  deleteNode(
    request: DeleteNodeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteNodeResponse) => void,
  ): ClientUnaryCall;
  /** Search for similar documents */
  search(
    request: SearchRequest,
    callback: (error: ServiceError | null, response: SearchResponse) => void,
  ): ClientUnaryCall;
  search(
    request: SearchRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SearchResponse) => void,
  ): ClientUnaryCall;
  search(
    request: SearchRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SearchResponse) => void,
  ): ClientUnaryCall;
  /** Batch insert (streaming) */
  batchInsert(
    callback: (error: ServiceError | null, response: BatchInsertResponse) => void,
  ): ClientWritableStream<InsertRequest>;
  batchInsert(
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BatchInsertResponse) => void,
  ): ClientWritableStream<InsertRequest>;
  batchInsert(
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BatchInsertResponse) => void,
  ): ClientWritableStream<InsertRequest>;
  batchInsert(
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BatchInsertResponse) => void,
  ): ClientWritableStream<InsertRequest>;
  /** Streaming search results */
  streamSearch(request: SearchRequest, options?: Partial<CallOptions>): ClientReadableStream<SearchResult>;
  streamSearch(
    request: SearchRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<SearchResult>;
  /** ACL Operations */
  grantPermission(
    request: GrantPermissionRequest,
    callback: (error: ServiceError | null, response: GrantPermissionResponse) => void,
  ): ClientUnaryCall;
  grantPermission(
    request: GrantPermissionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GrantPermissionResponse) => void,
  ): ClientUnaryCall;
  grantPermission(
    request: GrantPermissionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GrantPermissionResponse) => void,
  ): ClientUnaryCall;
  revokePermission(
    request: RevokePermissionRequest,
    callback: (error: ServiceError | null, response: RevokePermissionResponse) => void,
  ): ClientUnaryCall;
  revokePermission(
    request: RevokePermissionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RevokePermissionResponse) => void,
  ): ClientUnaryCall;
  revokePermission(
    request: RevokePermissionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RevokePermissionResponse) => void,
  ): ClientUnaryCall;
  /** Graph Operations */
  addEdge(
    request: AddEdgeRequest,
    callback: (error: ServiceError | null, response: AddEdgeResponse) => void,
  ): ClientUnaryCall;
  addEdge(
    request: AddEdgeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AddEdgeResponse) => void,
  ): ClientUnaryCall;
  addEdge(
    request: AddEdgeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AddEdgeResponse) => void,
  ): ClientUnaryCall;
  getNeighbors(
    request: GetNeighborsRequest,
    callback: (error: ServiceError | null, response: GetNeighborsResponse) => void,
  ): ClientUnaryCall;
  getNeighbors(
    request: GetNeighborsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetNeighborsResponse) => void,
  ): ClientUnaryCall;
  getNeighbors(
    request: GetNeighborsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetNeighborsResponse) => void,
  ): ClientUnaryCall;
  traverseGraph(
    request: TraverseGraphRequest,
    callback: (error: ServiceError | null, response: TraverseGraphResponse) => void,
  ): ClientUnaryCall;
  traverseGraph(
    request: TraverseGraphRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TraverseGraphResponse) => void,
  ): ClientUnaryCall;
  traverseGraph(
    request: TraverseGraphRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TraverseGraphResponse) => void,
  ): ClientUnaryCall;
  /** PubSub */
  subscribe(request: SubscribeRequest, options?: Partial<CallOptions>): ClientReadableStream<PubSubEvent>;
  subscribe(
    request: SubscribeRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<PubSubEvent>;
  /** SDM Write */
  writeMemory(
    request: WriteMemoryRequest,
    callback: (error: ServiceError | null, response: WriteMemoryResponse) => void,
  ): ClientUnaryCall;
  writeMemory(
    request: WriteMemoryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: WriteMemoryResponse) => void,
  ): ClientUnaryCall;
  writeMemory(
    request: WriteMemoryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: WriteMemoryResponse) => void,
  ): ClientUnaryCall;
  /** SDM Read */
  readMemory(
    request: ReadMemoryRequest,
    callback: (error: ServiceError | null, response: ReadMemoryResponse) => void,
  ): ClientUnaryCall;
  readMemory(
    request: ReadMemoryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ReadMemoryResponse) => void,
  ): ClientUnaryCall;
  readMemory(
    request: ReadMemoryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ReadMemoryResponse) => void,
  ): ClientUnaryCall;
  /** Agent Memory (Scratchpad) */
  addMemory(
    request: AddMemoryRequest,
    callback: (error: ServiceError | null, response: AddMemoryResponse) => void,
  ): ClientUnaryCall;
  addMemory(
    request: AddMemoryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AddMemoryResponse) => void,
  ): ClientUnaryCall;
  addMemory(
    request: AddMemoryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AddMemoryResponse) => void,
  ): ClientUnaryCall;
  getMemory(
    request: GetMemoryRequest,
    callback: (error: ServiceError | null, response: GetMemoryResponse) => void,
  ): ClientUnaryCall;
  getMemory(
    request: GetMemoryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetMemoryResponse) => void,
  ): ClientUnaryCall;
  getMemory(
    request: GetMemoryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetMemoryResponse) => void,
  ): ClientUnaryCall;
  clearMemory(
    request: ClearMemoryRequest,
    callback: (error: ServiceError | null, response: ClearMemoryResponse) => void,
  ): ClientUnaryCall;
  clearMemory(
    request: ClearMemoryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ClearMemoryResponse) => void,
  ): ClientUnaryCall;
  clearMemory(
    request: ClearMemoryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ClearMemoryResponse) => void,
  ): ClientUnaryCall;
  watchMemory(request: WatchMemoryRequest, options?: Partial<CallOptions>): ClientReadableStream<MemoryEvent>;
  watchMemory(
    request: WatchMemoryRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<MemoryEvent>;
  /** Cortex Session Operations */
  createSession(
    request: CreateSessionRequest,
    callback: (error: ServiceError | null, response: CreateSessionResponse) => void,
  ): ClientUnaryCall;
  createSession(
    request: CreateSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateSessionResponse) => void,
  ): ClientUnaryCall;
  createSession(
    request: CreateSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateSessionResponse) => void,
  ): ClientUnaryCall;
  snapshotSession(
    request: SnapshotSessionRequest,
    callback: (error: ServiceError | null, response: SnapshotSessionResponse) => void,
  ): ClientUnaryCall;
  snapshotSession(
    request: SnapshotSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SnapshotSessionResponse) => void,
  ): ClientUnaryCall;
  snapshotSession(
    request: SnapshotSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SnapshotSessionResponse) => void,
  ): ClientUnaryCall;
  loadSession(
    request: LoadSessionRequest,
    callback: (error: ServiceError | null, response: LoadSessionResponse) => void,
  ): ClientUnaryCall;
  loadSession(
    request: LoadSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LoadSessionResponse) => void,
  ): ClientUnaryCall;
  loadSession(
    request: LoadSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LoadSessionResponse) => void,
  ): ClientUnaryCall;
  commitSession(
    request: CommitSessionRequest,
    callback: (error: ServiceError | null, response: CommitSessionResponse) => void,
  ): ClientUnaryCall;
  commitSession(
    request: CommitSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CommitSessionResponse) => void,
  ): ClientUnaryCall;
  commitSession(
    request: CommitSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CommitSessionResponse) => void,
  ): ClientUnaryCall;
  dropSession(
    request: DropSessionRequest,
    callback: (error: ServiceError | null, response: DropSessionResponse) => void,
  ): ClientUnaryCall;
  dropSession(
    request: DropSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DropSessionResponse) => void,
  ): ClientUnaryCall;
  dropSession(
    request: DropSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DropSessionResponse) => void,
  ): ClientUnaryCall;
}

export const RiceDBClient = makeGenericClientConstructor(RiceDBService, "ricedb.RiceDB") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): RiceDBClient;
  service: typeof RiceDBService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
